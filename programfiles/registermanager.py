from .exceptions import NegativeStepsNumberError


def get_sequence_diversity(sequence):
    """
    Returns the number of pairs of neighbouring different bits in the given
    sequence of Boolean values.
    """
    result = 0
    for bit1, bit2 in zip(sequence[:-1], sequence[1:]):
        if bit1 ^ bit2:
            result += 1
    return result


def get_number_of_unique_sequences(sequences):
    """
    Returns the number of unique sequences in the given list.
    """
    unique_sequences = {tuple(sequence) for sequence in sequences}
    return len(unique_sequences)


class Register_Manager:
    """
    Class Register_Manager. Obtains outputs based on the given register.
    Attributes:
    :param register: The managed register.
    :type register: Register
    :param outputs: Outputs calculated based on the given register. Empty
                    dictionary before calculation.
    :type outputs: dict
    """
    def __init__(self, register):
        """
        Creates an object of type Register_Manager.
        """
        self.register = register
        self.outputs = {}

    def calculate_outputs(self, arguments):
        """
        Calculates sequences, average sequence diversity and space usage based
        on the managed register and saves it in outputs attribute. Does not
        preserve the original state of the register.
        """
        self.outputs['sequences'] = self._get_sequences(arguments)
        self.outputs['average_sequence_diversity'] = \
            self._get_average_sequence_diversity()
        self.outputs['space_usage'] = self._get_space_usage()

    def _get_sequences(self, arguments):
        """
        Returns a list of sequences generated for the managed shift register
        and arguments. Includes the starting state of the register.
        """
        sequences = [self.register.state()]
        if arguments.until_looped:
            self.register.add_new_state(sequences)
            max_sequences_amount = 2**len(self.register.flip_flop_functions())
            while not self.register.looped() and \
                    len(sequences) <= max_sequences_amount:
                self.register.add_new_state(sequences)
        else:
            if arguments.steps < 0:
                raise NegativeStepsNumberError
            for i in range(0, arguments.steps):
                self.register.add_new_state(sequences)
        return sequences

    def _get_average_sequence_diversity(self):
        """
        Returns the average number of pairs of neighbouring different bits in
        the register manager's list of generated sequences.
        """
        sequences = self.outputs.get("sequences", None)
        if sequences is None:
            return None
        return sum([get_sequence_diversity(sequence)
                    for sequence
                    in sequences]) / len(sequences)

    def _get_space_usage(self):
        """
        Returns the space usage of the given sequences. Space usage is how
        many unique sequences were generated divided by the maximum number of
        sequences generated by a register of this size.
        """
        sequences = self.outputs.get("sequences", None)
        if sequences is None:
            return None
        return (get_number_of_unique_sequences(sequences) /
                (2 ** len(sequences[0])))
