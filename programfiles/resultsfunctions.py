def get_sequences(register, arguments):
    """
    Returns a list of sequences generated for the given shift register and
    arguments. Includes the starting state of the register.
    """
    sequences = [register.state()]
    if arguments.until_looped:
        register.add_new_state(sequences)
        max_sequences_amount = 2**len(register.flip_flop_functions())
        while not register.looped() and len(sequences) <= max_sequences_amount:
            register.add_new_state(sequences)
    else:
        for i in range(0, arguments.steps):
            register.add_new_state(sequences)
    return sequences


def get_sequence_diversity(sequence):
    """
    Returns the number of pairs of neighbouring different bits in the given
    sequence of Boolean values.
    """
    result = 0
    for bit1, bit2 in zip(sequence[:-1], sequence[1:]):
        if bit1 ^ bit2:
            result += 1
    return result


def get_average_sequence_diversity(sequences):
    """
    Returns the average number of pairs of neighbouring different bits in the
    given list of sequences of Boolean values.
    """
    return sum([get_sequence_diversity(sequence)
                for sequence
                in sequences]) / len(sequences)


def get_number_of_unique_sequences(sequences):
    """
    Returns the number of unique sequences in the given list.
    """
    unique_sequences = {tuple(sequence) for sequence in sequences}
    return len(unique_sequences)


def get_space_usage(sequences):
    """
    Returns the space usage of the given sequences in %. Space usage is how
    many unique sequences were generated divided by the maximum number of
    sequences generated by a register of this size.
    """
    return (get_number_of_unique_sequences(sequences) /
            (2 ** len(sequences[0]))) * 100
